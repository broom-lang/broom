%name BroomLexer;

%defs (
    structure Tokens = BroomTokens
    type lex_result = Tokens.token
    fun eof () = Tokens.EOF
);

%let alpha = [a-zA-Z];
%let digit = [0-9];
%let firstConstituent = {alpha} | _;
%let constituent = {firstConstituent} | {digit};

val       => (Tokens.VAL);
fun       => (Tokens.FUN);
type      => (Tokens.TYPE);
pi        => (Tokens.PI);
do        => (Tokens.DO);
module    => (Tokens.MODULE);
interface => (Tokens.INTERFACE);
fn        => (Tokens.FN);
match     => (Tokens.MATCH);
end       => (Tokens.END);

"=>" => (Tokens.DARROW);
"="  => (Tokens.EQ);
"->" => (Tokens.ARROW);
"~>" => (Tokens.WARROW);
"|"  => (Tokens.BAR);
"&"  => (Tokens.AMP);
".." => (Tokens.DDOT);
"."  => (Tokens.DOT);
","  => (Tokens.COMMA);
:    => (Tokens.COLON);
";"  => (Tokens.SEMI);

"(" => (Tokens.LPAREN);
")" => (Tokens.RPAREN);
"[" => (Tokens.LBRACKET);
"]" => (Tokens.RBRACKET);
"{" => (Tokens.LBRACE);
"}" => (Tokens.RBRACE);

{digit}+ => (Tokens.INT (valOf (Int.fromString yytext)));
True     => (Tokens.BOOL true);
False    => (Tokens.BOOL false);

@ {constituent}+                  => (Tokens.META (Name.fromString (String.extract (yytext, 1, NONE))));
{firstConstituent} {constituent}* => (Tokens.ID (Name.fromString yytext));

# [^\n]*           => (continue ());
" " | \n | \r | \t => (continue ());

