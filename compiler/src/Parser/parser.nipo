parser BroomParser where

{ open BroomTokens }

token {BroomTokens.t}
    = Val 'val'
    | In 'in'
    | Fun 'fun'
    | Type 'type'
    | Do 'do'
    | Module 'module'
    | Interface 'interface'
    | If 'if'
    | Then 'then'
    | Else 'else'
    | End 'end'
    | Eq '='
    | Arrow '->'
    | Bar '|'
    | Amp '&'
    | Colon ':'
    | Dot '.'
    | DDot '..'
    | Semi ';'
    | Comma ','
    | LBrace '{'
    | RBrace '}'
    | LParen '('
    | RParen ')'
    | Id
    | Int
    | Bool
    ;

rules

start program = stmts;

# Statements and Blocks

stmt
    = def ';'
    | expr ';'
    ;

def
    = 'val' pattern '=' expr
    | 'type' Id '=' expr
    ;

stmts = stmt* ;

block
    = def ';' block
    | expr ( ';' block
           | 'end' )
    ;

# Expressions/Types

expr = ascription;

typ = expr;

ascription = arrow (':' arrow)*;

arrow
    = 'fun' Id (':' binapp)? '->' arrow
    | binapp ('->' arrow)?
    ; 

binapp = app;

app = select+;

select = nestable ('.' Id)* ;

nestable
    = '{' ( '|' clauses '}'
          | '}' # empty record
          | ':' '}' # empty record type
          | '..' expr '}' # ext-only record
          | '&' typ '}' # ext-only record type
          | Id ( recordTail '}' # pun-starting record
               | '=' expr recordTail '}' # nonpun-starting record
               | ':' typ rowTail '}' ) ) # nonempty record type
    | 'do' block
    | 'module' stmts 'end'
    | 'interface' decls=decl* 'end'
    | '(' ('=' expr ')'
          | expr ')')
    #| 'type'
    | atom
    ;

clauses = paramPattern '->' expr ('|' paramPattern '->' expr)* ;

recordTail = (',' recordField)* ('..' expr)? ;

recordField = Id ('=' expr)? ;

rowTail = (',' rowField)* ('&' typ)? '}' ;

rowField = Id ':' typ ;

decl
    = 'val' Id ':' typ ';'
    | 'type' Id ('=' typ)? ';'
    ;

atom
    = Id
    | const
    ;

const
    = Int
    | Bool
    ;

# Patterns

pattern
    = Id (':' typ)?
    ;

paramPattern
    = Id (':' patternTyp)?
    ;

patternTyp = binapp ;

