parser BroomParser where

{ open BroomTokens }

token {BroomTokens.t}
    = Val 'val'
    | In 'in'
    | Fun 'fun'
    | Type 'type'
    | Do 'do'
    | Module 'module'
    | Interface 'interface'
    | If 'if'
    | Then 'then'
    | Else 'else'
    | End 'end'
    | Eq '='
    | Arrow '->'
    | Bar '|'
    | Amp '&'
    | Colon ':'
    | Dot '.'
    | DDot '..'
    | Semi ';'
    | Comma ','
    | LBrace '{'
    | RBrace '}'
    | LParen '('
    | RParen ')'
    | Id
    | Int
    | Bool
    ;

rules

start program = stmts;

# Statements

stmts = stmts=stmt* ;

stmt
    = pattern '=' expr ';'
    | 'type' Id '=' expr ';'
    | expr ';'
    ;

# Expressions/Types

expr = ascription;

typ = expr;

ascription = arrow (':' arrow)*;

arrow
    = 'fun' Id (':' binapp)? '->' arrow
    | binapp ('->' arrow)?
    ; 

binapp = app;

app = select+;

select = nestable ('.' Id)* ;

nestable
    = '{' ( '|' params=(paramPattern '->')+ expr '}'
          | '}' # empty record
          | ':' '}' # empty record type
          | '..' expr '}' # ext-only record
          | '&' typ '}' # ext-only record type
          | Id ( '}' # record of one pun field
               | ',' recordField (',' recordField)* ('..' expr)? '}' # pun-starting nonempty record
               | '=' expr (',' recordField)* ('..' expr)? '}' # nonempty record
               | ':' typ (',' rowField)* ('&' typ)? '}' # nonempty record type
               | '..' expr '}' ) ) # record of one pun and ext
    | 'do' stmts expr 'end'
    | 'module' stmts 'end'
    | 'interface' decls=decl* 'end'
    | '(' ('=' expr ')'
          | expr ')')
    #| 'type'
    | atom
    ;

recordField = Id ('=' expr)? ;

rowField = Id ':' typ ;

decl
    = 'val' Id ':' typ ';'
    | 'type' Id ('=' typ)? ';'
    ;

atom
    = Id
    | const
    ;

const
    = Int
    | Bool
    ;

# Patterns

pattern
    = Id (':' typ)?
    ;

paramPattern
    = Id (':' patternTyp)?
    ;

patternTyp = binapp ;

