parser BroomParser where

{ open BroomTokens }

token {BroomTokens.t}
    = Val 'val'
    | Fun 'fun'
    | Type 'type'
    | Do 'do'
    | Module 'module'
    | Interface 'interface'
    | If 'if'
    | Then 'then'
    | Else 'else'
    | End 'end'
    | Eq '='
    | Arrow '->'
    | Bar '|'
    | Amp '&'
    | Colon ':'
    | Dot '.'
    | DDot '..'
    | Semi ';'
    | Comma ','
    | LBrace '{'
    | RBrace '}'
    | LParen '('
    | RParen ')'
    | Id
    | Int
    | Bool
    ;

rules

start program = stmts;

# Statements

stmts = stmts=stmt* ;

stmt
    = pattern '=' expr
    | 'type' Id '=' expr
    ;

# Expressions

expr = ascription;

ascription = ascriptee (':' typ)*;

ascriptee
    = 'if' expr 'then' expr 'else' ascriptee
    | binapp
    ;

binapp = app;

app = nestable+;

nestable
    = purelyExpr ('.' Id)*
    | purelyTyp
    | '(' expr ')'
    ;

purelyExpr
    = '{' '|' params=(paramPattern '->')+ expr '}'
    | 'do' stmts ';' expr 'end'
    | '{' recordFields ('..' expr)? '}'
    | 'module' stmts 'end'
    | atom
    ;

recordFields
    = recordField (',' recordField)*
    |
    ;

recordField = Id ('=' expr)? ;

atom
    = Id
    | const
    ;

const
    = Int
    | Bool
    ;

# Patterns

pattern
    = Id (':' typ)?
    ;

paramPattern
    = Id (':' nonArrowTyp)?
    ;

# Types

typ
    = 'fun' Id (':' nestableTyp)? '->' typ
    | nonArrowTyp ('->' typ)?
    ;

nonArrowTyp
    = purelyTyp
    | '(' typ ')'
    | expr
    ;

nestableTyp
    = purelyTyp
    | '(' typ ')'
    ;

purelyTyp
    = 'type'
    | '{' rowType '}'
    | '(' '=' expr ')'
    | 'interface' decls=decl* 'end'
    ;

rowType
    = ':'
    | fields=rowField* ('&' typ)?
    ;

rowFields
    = rowField (',' rowField)*
    |
    ;

rowField = Id ':' typ ;

decl
    = 'val' Id ':' typ
    | 'type' Id ('=' typ)?
    ;

