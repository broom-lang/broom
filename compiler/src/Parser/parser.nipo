parser BroomParser where

{%
open BroomTokens
structure Term = Cst.Term
structure Type = Cst.Type
datatype explicitness = datatype Cst.explicitness
%}

token {%BroomTokens.t%}
    = Val 'val'
    | Fun 'fun'
    | Type 'type'
    | Pi 'pi'
    | Begin 'begin'
    | Match 'match'
    | Do 'do'
    | Return 'return'
    | Module 'module'
    | Interface 'interface'
    | End 'end'
    | Eq '='
    | DArrow '=>'
    | Arrow '->'
    | Bar '|'
    | Amp '&'
    | Colon ':'
    | Dot '.'
    | DDot '..'
    | Comma ','
    | Semi ';'
    | LBrace '{'
    | RBrace '}'
    | LParen '('
    | RParen ')'
    | Id
    | Int
    | Bool
    ;

rules

start program = stmts {% Vector.fromList stmts %};

# Statements and Blocks

stmt
    = pos 'val' pattern '=' expr {% Term.Val (pos, pattern, expr) %}
    | pos 'fun' Id pats=apat+ '=' expr {% let
          fun step (pattern, body) = Term.Fn (pos, Explicit, #[{pattern, body}])
          in Term.Val (pos, Term.Def (pos, valOf (toName tokId)), List.foldr step expr pats)
      end %}
    | pos 'type' Id pats=kpat* '=' typ {% let
          fun step ((pos, {var, typ}), body) =
              Term.Fn (pos, Explicit, #[{pattern = Term.AnnP (pos, {pat = Term.Def (pos, var), typ}), body}])
          in Term.Val ( pos, Term.Def (pos, valOf (toName tokId))
                      , List.foldr step (Term.Type (pos, typ)) pats )
      end %}
    | ';' expr {% Term.Expr expr %}
    ;

stmts = stmts=stmt* {% stmts %};

# Expressions/Types

expr
    = ascription {% ascription %}
    | pos 'type' {% Term.Type (pos, Type.TypeT pos) %}
    ;

typ = expr {% Type.Path expr %};

nonArrowTyp
    = binapp {% Type.Path binapp %}
    | pos 'type' {% Type.TypeT pos %}
    ;

ascription = pos arrow typ=(':' typ {%typ%})? {% case typ
                                                 of SOME t => Term.Ann (pos, arrow, t)
                                                  | NONE => arrow %};

arrow
    = pos 'pi' piParam arr body=arrow
      {% Term.Type (pos, Type.Pi (pos, piParam, arr, Type.Path body)) %}
    | pos binapp codomain=(arr arrow {% (arr, arrow) %})?
      {% case codomain
         of SOME (arr, cd) =>
             let val def = {var = Name.fresh (), typ = SOME (Type.Path binapp)}
             in Term.Type (pos, Type.Pi (pos, def, arr, Type.Path cd))
             end
          | NONE => binapp %}
    ;

binapp = app {% app %};

app = pos select selects=select*
    {% List.foldl (fn (arg, callee) => Term.App (pos, {callee, arg}))
                  select selects %};

select = pos nestable fields=('.' Id {% valOf (toName tokId) %})* 
       {% List.foldl (fn (field, r) => Term.Field (pos, r, field))
                     nestable fields %};

nestable
    = pos '{' res=( '|' clauses '}' {% let val (explicitness, clauses) = clauses
                                       in Term.Fn (pos, explicitness, clauses)
                                       end %}
                  | '}'             {% Term.Record (pos, {fields = #[], ext = NONE}) %}
                  | ':' '}'         {% Term.Type (pos, Type.RecordT (pos, Type.EmptyRow pos)) %}
                  | '..' expr '}'   {% Term.Record (pos, {fields = #[], ext = SOME expr}) %}
                  | '&' res=( '}'     {% Term.Type (pos, Type.WildRow pos) %}
                            | typ '}' {% Term.Type (pos, Type.RowExt (pos, {fields = #[], ext = typ})) %} )
                            {% res %}
                  | Id res=( recordTail '}'          {% let val {fields, ext} = recordTail
                                                            val name = valOf (toName tokId)
                                                            val field = (name, Term.Use (pos, name))
                                                            val fields = Vector.fromList (field :: fields)
                                                        in Term.Record (pos, {fields, ext})
                                                        end %}
                           | '=' expr recordTail '}' {% let val {fields, ext} = recordTail
                                                            val fields = Vector.fromList ((valOf (toName tokId), expr) :: fields)
                                                        in Term.Record (pos, {fields, ext})
                                                        end %}
                           | ':' typ rowTail '}'     {% let val {fields, ext} = rowTail
                                                            val fields = Vector.fromList ((valOf (toName tokId), typ) :: fields)
                                                        in Term.Type (pos, Type.RecordT (pos, Type.RowExt (pos, {fields, ext})))
                                                        end %} )
                       {% res %} )
              {% res %}
    | pos 'match' select '{' '|' clauses=explicitClauses '}' {% Term.Match (pos, select, clauses) %}
    | pos 'do' stmts 'end' {% case stmts
                              of [] => Term.Let (pos, #[], Term.Const (pos, Const.Unit))
                               | _ => let val rec loop =
                                              fn stmts as [Term.Val _] =>
                                                  (stmts, Term.Const (pos, Const.Unit))
                                               | [Term.Expr body] =>
                                                  ([], body)
                                               | stmt :: stmts =>
                                                  let val (stmts', body) = loop stmts
                                                  in (stmt :: stmts', body)
                                                  end
                                               | [] => ([], Term.Const (pos, Const.Unit))
                                          val (stmts, body) = loop stmts
                                      in Term.Let (pos, Vector.fromList stmts, body)
                                      end %}
    | pos 'module' stmts 'end' {% Term.Module (pos, Vector.fromList stmts) %}
    | pos 'interface' decls=decl* 'end' {% Term.Type (pos, Type.Interface (pos, Vector.fromList decls)) %}
    | pos '(' res=('=' expr ')' {% Term.Type (pos, Type.Singleton (pos, expr)) %}
                  | expr ')'    {% expr %} )
              {% res %}
    | atom {% atom %}
    ;

clauses = pattern=paramPattern clauses=( '->' body=expr clauses=('|' explicitClause {% explicitClause %})*
                                         {% (Explicit, Vector.fromList ({pattern, body} :: clauses)) %}
                                       | '=>' body=expr clauses=('|' implicitClause {% implicitClause %})*
                                         {% (Implicit, Vector.fromList ({pattern, body} :: clauses)) %} )
                               {% clauses %};

explicitClauses = explicitClause clauses=('|' explicitClause {% explicitClause %})*
                  {% Vector.fromList (explicitClause :: clauses) %};

explicitClause = pattern=paramPattern '->' body=expr {% {pattern, body} %};
implicitClause = pattern=paramPattern '=>' body=expr {% {pattern, body} %};

recordTail = fields=(',' recordField {%recordField%})* ext=('..' expr {%expr%})? {% {fields, ext} %};

recordField = pos Id expr=('=' expr {%expr%})? {% case expr
                                                  of SOME expr => (valOf (toName tokId), expr)
                                                   | NONE => (valOf (toName tokId), Term.Use (pos, valOf (toName tokId))) %};

rowTail = fields=(',' rowField {%rowField%})* pos ext=rowExt {% {fields, ext} %};

rowExt
    = pos '&' ext=typ? {% getOpt (ext, Type.WildRow pos) %}
    | pos              {% Type.EmptyRow pos %}
    ;

rowField = Id ':' typ {% (valOf (toName tokId), typ) %};

decl
    = 'val' Id ':' typ {% (valOf (toName tokId), typ) %}
    | pos 'type' Id pats=kpat* typ=('=' pos typ {% (pos, typ) %})?
      {% let val codomain = case typ
                            of SOME (ptyp as (_, typ)) => Type.Singleton (pos, Term.Type ptyp)
                             | NONE => Type.TypeT pos
             fun step ((pos, {var, typ}), codomain) =
                 Type.Pi (pos, {var, typ = SOME typ}, Explicit, codomain)
         in (valOf (toName tokId), List.foldr step codomain pats)
         end %}
    ;

atom
    = pos Id    {% let val name = valOf (toName tokId)
                   in  case Name.toString name (* HACK *)
                       of "unit" => Term.Type (pos, Type.Prim (pos, Type.Prim.Unit))
                        | "int" => Term.Type (pos, Type.Prim (pos, Type.Prim.I32))
                        | _ => Term.Use (pos, name)
                   end %}
    | pos const {% Term.Const (pos, const) %}
    ;

const
    = Int  {% Const.Int (valOf (toInt tokInt)) %}
    | Bool {% Const.Bool (valOf (toBool tokBool)) %}
    ;

arr
    = '->' {% Explicit %}
    | '=>' {% Implicit %}
    ;

# Patterns

piParam = Id typ=(':' nonArrowTyp {% nonArrowTyp %})? {% {var = valOf (toName tokId), typ} %};

pattern
    = pos apat typ=(':' typ {% typ %})? {% case typ
                                           of SOME typ => Term.AnnP (pos, {pat = apat, typ})
                                            | NONE => apat %}
    ;

paramPattern
    = pos apat typ=(':' nonArrowTyp {% nonArrowTyp %})? {% case typ
                                                           of SOME typ => Term.AnnP (pos, {pat = apat, typ})
                                                            | NONE => apat %}
    ;

apat
    = '(' pattern ')' {% pattern %}
    | pos Id          {% Term.Def (pos, valOf (toName tokId)) %}
    | pos const       {% Term.ConstP (pos, const) %}
    ;

kpat
    = pos Id                      {% (pos, {var = valOf (toName tokId), typ = (Type.TypeT pos)}) %}
    | pos '(' Id ':' kind=typ ')' {% (pos, {var = valOf (toName tokId), typ = kind}) %}
    ;

