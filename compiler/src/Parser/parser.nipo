parser BroomParser where

{
open BroomTokens
structure Term = Cst.Term
structure Type = Cst.Type
}

token {BroomTokens.t}
    = Val 'val'
    | Fun 'fun'
    | Type 'type'
    | Pi 'pi'
    | Do 'do'
    | Module 'module'
    | Interface 'interface'
    | End 'end'
    | Eq '='
    | Arrow '->'
    | Bar '|'
    | Amp '&'
    | Colon ':'
    | Dot '.'
    | DDot '..'
    | Semi ';'
    | Comma ','
    | LBrace '{'
    | RBrace '}'
    | LParen '('
    | RParen ')'
    | Id
    | Int
    | Bool
    ;

rules

start program = stmts { stmts };

# Statements and Blocks

valDef
    = pos 'val' pattern '=' expr { Term.Val (pos, pattern, expr) }
    | pos 'fun' pats=apat+ '=' expr { Term.funDef (pos, pats, expr) }
    ;

stmt
    = valDef ';' { valDef }
    | pos 'type' res=( Id '=' expr ';' { Term.typeDef (pos, tokId, expr) }
                     | ';'             { Term.Expr (Term.Type (pos, Type.TypeT)) } )
                 { res }
    | ascription ';' { Term.Expr ascription }
    ;

stmts = stmt* ;

block
    = valDef ';' block { let val (stmts, body) = block
                         in (valDef :: stmts, body)
                         end }
    | pos 'type' res=( Id '=' expr ';' block { let val (stmts, body) = block
                                               in (Term.typeDef (pos, tokId, expr) :: stmts, body)
                                               end }
                     | ';' block             { let val (stmts, body) = block
                                               in (Term.Expr (Term.Type (pos, Type.TypeT)) :: stmts, body)
                                               end }
                     | 'end'                 { ([], Term.Type (pos, Type.TypeT)) } )
                 { res }
    | ascription res=( ';' block { let val (stmts, body) = block
                                   in (Term.Expr ascription :: stmts, body)
                                   end }
                     | 'end'     { ([], ascription) } )
                 { res }
    ;

# Expressions/Types

expr
    = ascription { ascription }
    | pos 'type' { Term.Type (pos, Type.TypeT) }
    ;

typ = expr { Type.Path expr };

ascription = arrow arrows=(':' arrow { arrow })*
           { List.foldr (fn (arrow, res) => Term.Ann (pos, arrow, Type.Path res))
                        arrow arrows };

arrow
    = 'pi' Id (':' binapp)? '->' arrow
    | binapp ('->' arrow)?
    ; 

binapp = app { app };

app = select selects=select* ;

select = nestable ('.' Id)* ;

nestable
    = '{' ( '|' clauses '}'
          | '}' # empty record
          | ':' '}' # empty record type
          | '..' expr '}' # ext-only record
          | '&' typ '}' # ext-only record type
          | Id ( recordTail '}' # pun-starting record
               | '=' expr recordTail '}' # nonpun-starting record
               | ':' typ rowTail '}' ) ) # nonempty record type
    | 'do' block
    | 'module' stmts 'end'
    | 'interface' decls=decl* 'end'
    | '(' ('=' expr ')'
          | expr ')')
    | atom
    ;

clauses = paramPattern '->' expr ('|' paramPattern '->' expr)* ;

recordTail = (',' recordField)* ('..' expr)? ;

recordField = Id ('=' expr)? ;

rowTail = (',' rowField)* ('&' typ)? '}' ;

rowField = Id ':' typ ;

decl
    = 'val' Id ':' typ ';'
    | 'type' Id ('=' typ)? ';'
    ;

atom
    = Id
    | const
    ;

const
    = Int
    | Bool
    ;

# Patterns

pattern
    = apat (':' typ)?
    ;

paramPattern
    = apat (':' binapp)?
    ;

apat
    = '(' pattern ')'
    | Id
    ;

