parser BroomParser where

{%
open BroomTokens
structure Term = Cst.Term
structure Type = Cst.Type
%}

token {%BroomTokens.t%}
    = Val 'val'
    | Fun 'fun'
    | Type 'type'
    | Pi 'pi'
    | Begin 'begin'
    | Do 'do'
    | Return 'return'
    | Module 'module'
    | Interface 'interface'
    | End 'end'
    | Eq '='
    | Arrow '->'
    | Bar '|'
    | Amp '&'
    | Colon ':'
    | Dot '.'
    | DDot '..'
    | Comma ','
    | LBrace '{'
    | RBrace '}'
    | LParen '('
    | RParen ')'
    | Id
    | Int
    | Bool
    ;

rules

start program = stmts {% stmts %};

# Statements and Blocks

stmt
    = pos 'val' pattern '=' expr {% Term.Val (pos, pattern, expr) %}
    | pos 'fun' pats=apat+ '=' expr {% raise Fail "unimplemented" %}
    | pos 'type' Id '=' typ {% Term.Val ( pos, {var = valOf (toName tokId), typ = NONE}
                                        , Term.Type (pos, typ) ) %}
    | 'do' expr {% Term.Expr expr %}
    ;

stmts = stmts=stmt* {% stmts %};

# Expressions/Types

expr
    = ascription {% ascription %}
    | pos 'type' {% Term.Type (pos, Type.TypeT pos) %}
    ;

typ = expr {% Type.Path expr %};

nonArrowTyp = binapp {% Type.Path binapp %};

ascription = pos arrow typ=(':' typ {%typ%})? {% case typ
                                                 of SOME t => Term.Ann (pos, arrow, t)
                                                  | NONE => arrow %};

arrow
    = pos 'pi' paramPattern '->' body=arrow {% Term.Type (pos, Type.Pi (pos, paramPattern, Type.Path body)) %}
    | pos binapp codomain=('->' arrow {%arrow%})?
      {% case codomain
         of SOME cd => Term.Type (pos, Type.Pi (pos, {var = Name.fresh (), typ = SOME (Type.Path binapp)}, Type.Path cd))
          | NONE => binapp %}
    ; 

binapp = app {% app %};

app = pos select selects=select*
    {% List.foldl (fn (arg, callee) => Term.App (pos, {callee, arg}))
                  select selects %};

select = pos nestable fields=('.' Id {% valOf (toName tokId) %})* 
       {% List.foldl (fn (field, r) => Term.Field (pos, r, field))
                     nestable fields %};

nestable
    = pos '{' res=( '|' clauses '}' {% raise Fail "unimplemented" %}
                  | '}'             {% Term.Record (pos, {fields = #[], ext = NONE}) %}
                  | ':' '}'         {% Term.Type (pos, Type.EmptyRow pos) %}
                  | '..' expr '}'   {% Term.Record (pos, {fields = #[], ext = SOME expr}) %}
                  | '&' typ '}'     {% Term.Type (pos, Type.RowExt (pos, {fields = #[], ext = typ})) %}
                  | Id res=( recordTail '}'          {% let val {fields, ext} = recordTail
                                                            val name = valOf (toName tokId)
                                                            val field = (name, Term.Use (pos, name))
                                                            val fields = Vector.fromList (field :: fields)
                                                        in Term.Record (pos, {fields, ext})
                                                        end %}
                           | '=' expr recordTail '}' {% let val {fields, ext} = recordTail
                                                            val fields = Vector.fromList ((valOf (toName tokId), expr) :: fields)
                                                        in Term.Record (pos, {fields, ext})
                                                        end %}
                           | ':' typ rowTail '}'     {% let val {fields, ext} = rowTail
                                                            val fields = Vector.fromList ((valOf (toName tokId), typ) :: fields)
                                                        in Term.Type (pos, Type.RowExt (pos, {fields, ext}))
                                                        end %} )
                       {% res %} )
              {% res %}
    | pos 'begin' stmts 'return' body=expr 'end' {% Term.Let (pos, Vector.fromList stmts, body) %}
    | pos 'module' stmts 'end' {% Term.Module (pos, Vector.fromList stmts) %}
    | pos 'interface' decls=decl* 'end' {% Term.Type (pos, Type.Interface (pos, Vector.fromList decls)) %}
    | pos '(' res=('=' expr ')' {% Term.Type (pos, Type.Singleton (pos, expr)) %}
                  | expr ')'    {% expr %} )
              {% res %}
    | atom {% atom %}
    ;

clauses = clause clauses=('|' clause {% clause %})* {% Vector.fromList (clause :: clauses) %};

clause = pattern=paramPattern '->' body=expr {% {pattern, body} %};

recordTail = fields=(',' recordField {%recordField%})* ext=('..' expr {%expr%})? {% {fields, ext} %};

recordField = pos Id expr=('=' expr {%expr%})? {% case expr
                                                  of SOME expr => (valOf (toName tokId), expr)
                                                   | NONE => (valOf (toName tokId), Term.Use (pos, valOf (toName tokId))) %};

rowTail = fields=(',' rowField {%rowField%})* pos ext=('&' typ {%typ%})?
        {% {fields, ext = getOpt (ext, Type.EmptyRow pos)} %};

rowField = Id ':' typ {% (valOf (toName tokId), typ) %};

decl
    = 'val' Id ':' typ {% (valOf (toName tokId), typ) %}
    | pos 'type' Id typ=('=' pos typ {% (pos, typ) %})?
      {% case typ
         of SOME (pos, t) => (valOf (toName tokId), Type.Singleton (pos, Term.Type (pos, t)))
          | NONE => (valOf (toName tokId), Type.TypeT pos) %}
    ;

atom
    = pos Id    {% Term.Use (pos, valOf (toName tokId)) %}
    | pos const {% Term.Const (pos, const) %}
    ;

const
    = Int  {% Const.Int (valOf (toInt tokInt)) %}
    | Bool {% Const.Bool (valOf (toBool tokBool)) %}
    ;

# Patterns

pattern
    = apat typ=(':' typ {%typ%})? {% {var = apat, typ} %}
    ;

paramPattern
    = apat typ=(':' nonArrowTyp {%nonArrowTyp%})? {% {var = apat, typ} %}
    ;

apat
    = '(' pattern ')' {% raise Fail "unimplemented" %}
    | Id              {% valOf (toName tokId) %}
    ;

