parser BroomParser where

{%
open BroomTokens
structure Term = Cst.Term
structure Type = Cst.Type
%}

token {%BroomTokens.t%}
    = Val 'val'
    | Fun 'fun'
    | Type 'type'
    | Pi 'pi'
    | Begin 'begin'
    | Match 'match'
    | Do 'do'
    | Return 'return'
    | Module 'module'
    | Interface 'interface'
    | End 'end'
    | Eq '='
    | Arrow '->'
    | Bar '|'
    | Amp '&'
    | Colon ':'
    | Dot '.'
    | DDot '..'
    | Comma ','
    | Semi ';'
    | LBrace '{'
    | RBrace '}'
    | LParen '('
    | RParen ')'
    | Id
    | Int
    | Bool
    ;

rules

start program = stmts {% Vector.fromList stmts %};

# Statements and Blocks

stmt
    = pos 'val' pattern '=' expr {% Term.Val (pos, pattern, expr) %}
    | pos 'fun' Id pats=apat+ '=' expr {% let
          fun step (pat, body) = let val var = Name.fresh ()
                                 in Term.Fn ( pos, {var, typ = NONE}
                                            , Term.Let (pos, #[Term.Val (pos, pat, Term.Use (pos, var))], body)  )
                                 end
          in Term.Val (pos, Term.Def (pos, valOf (toName tokId)), List.foldr step expr pats)
      end %}
    | pos 'type' Id '=' typ {% Term.Val ( pos, Term.Def (pos, valOf (toName tokId))
                                        , Term.Type (pos, typ) ) %}
    | ';' expr {% Term.Expr expr %}
    ;

stmts = stmts=stmt* {% stmts %};

# Expressions/Types

expr
    = ascription {% ascription %}
    | pos 'type' {% Term.Type (pos, Type.TypeT pos) %}
    ;

typ = expr {% Type.Path expr %};

nonArrowTyp
    = binapp {% Type.Path binapp %}
    | pos 'type' {% Type.TypeT pos %}
    ;

ascription = pos arrow typ=(':' typ {%typ%})? {% case typ
                                                 of SOME t => Term.Ann (pos, arrow, t)
                                                  | NONE => arrow %};

arrow
    = pos 'pi' piParam '->' body=arrow {% Term.Type (pos, Type.Pi (pos, piParam, Type.Path body)) %}
    | pos binapp codomain=('->' arrow {%arrow%})?
      {% case codomain
         of SOME cd => Term.Type (pos, Type.Pi (pos, {var = Name.fresh (), typ = SOME (Type.Path binapp)}, Type.Path cd))
          | NONE => binapp %}
    ; 

binapp = app {% app %};

app = pos select selects=select*
    {% List.foldl (fn (arg, callee) => Term.App (pos, {callee, arg}))
                  select selects %};

select = pos nestable fields=('.' Id {% valOf (toName tokId) %})* 
       {% List.foldl (fn (field, r) => Term.Field (pos, r, field))
                     nestable fields %};

nestable
    = pos '{' res=( '|' clauses '}' {% let val var = Name.fresh ()
                                       in Term.Fn ( pos, {var, typ = NONE}
                                                  , Term.Match (pos, Term.Use (pos, var), clauses) )
                                       end %}
                  | '}'             {% Term.Record (pos, {fields = #[], ext = NONE}) %}
                  | ':' '}'         {% Term.Type (pos, Type.EmptyRow pos) %}
                  | '..' expr '}'   {% Term.Record (pos, {fields = #[], ext = SOME expr}) %}
                  | '&' res=( '}'     {% Term.Type (pos, Type.WildRow pos) %}
                            | typ '}' {% Term.Type (pos, Type.RowExt (pos, {fields = #[], ext = typ})) %} )
                            {% res %}
                  | Id res=( recordTail '}'          {% let val {fields, ext} = recordTail
                                                            val name = valOf (toName tokId)
                                                            val field = (name, Term.Use (pos, name))
                                                            val fields = Vector.fromList (field :: fields)
                                                        in Term.Record (pos, {fields, ext})
                                                        end %}
                           | '=' expr recordTail '}' {% let val {fields, ext} = recordTail
                                                            val fields = Vector.fromList ((valOf (toName tokId), expr) :: fields)
                                                        in Term.Record (pos, {fields, ext})
                                                        end %}
                           | ':' typ rowTail '}'     {% let val {fields, ext} = rowTail
                                                            val fields = Vector.fromList ((valOf (toName tokId), typ) :: fields)
                                                        in Term.Type (pos, Type.RowExt (pos, {fields, ext}))
                                                        end %} )
                       {% res %} )
              {% res %}
    | pos 'match' select '{' '|' clauses '}' {% Term.Match (pos, select, clauses) %}
    | pos 'do' stmts 'end' {% case stmts
                              of [] => Term.Let (pos, #[], Term.Const (pos, Const.Unit))
                               | _ => let val rec loop =
                                              fn stmts as [Term.Val _] =>
                                                  (stmts, Term.Const (pos, Const.Unit))
                                               | [Term.Expr body] =>
                                                  ([], body)
                                               | stmt :: stmts =>
                                                  let val (stmts', body) = loop stmts
                                                  in (stmt :: stmts', body)
                                                  end
                                          val (stmts, body) = loop stmts
                                      in Term.Let (pos, Vector.fromList stmts, body)
                                      end %}
    | pos 'module' stmts 'end' {% Term.Module (pos, Vector.fromList stmts) %}
    | pos 'interface' decls=decl* 'end' {% Term.Type (pos, Type.Interface (pos, Vector.fromList decls)) %}
    | pos '(' res=('=' expr ')' {% Term.Type (pos, Type.Singleton (pos, expr)) %}
                  | expr ')'    {% expr %} )
              {% res %}
    | atom {% atom %}
    ;

clauses = clause clauses=('|' clause {% clause %})* {% Vector.fromList (clause :: clauses) %};

clause = pattern=paramPattern '->' body=expr {% {pattern, body} %};

recordTail = fields=(',' recordField {%recordField%})* ext=('..' expr {%expr%})? {% {fields, ext} %};

recordField = pos Id expr=('=' expr {%expr%})? {% case expr
                                                  of SOME expr => (valOf (toName tokId), expr)
                                                   | NONE => (valOf (toName tokId), Term.Use (pos, valOf (toName tokId))) %};

rowTail = fields=(',' rowField {%rowField%})* pos ext=rowExt {% {fields, ext} %};

rowExt
    = pos '&' ext=typ? {% getOpt (ext, Type.WildRow pos) %}
    | pos              {% Type.EmptyRow pos %}
    ;

rowField = Id ':' typ {% (valOf (toName tokId), typ) %};

decl
    = 'val' Id ':' typ {% (valOf (toName tokId), typ) %}
    | pos 'type' Id typ=('=' pos typ {% (pos, typ) %})?
      {% case typ
         of SOME (pos, t) => (valOf (toName tokId), Type.Singleton (pos, Term.Type (pos, t)))
          | NONE => (valOf (toName tokId), Type.TypeT pos) %}
    ;

atom
    = pos Id    {% let val name = valOf (toName tokId)
                   in  case Name.toString name (* HACK *)
                       of "unit" => Term.Type (pos, Type.Prim (pos, Type.Prim.Unit))
                        | "int" => Term.Type (pos, Type.Prim (pos, Type.Prim.I32))
                        | _ => Term.Use (pos, name)
                   end %}
    | pos const {% Term.Const (pos, const) %}
    ;

const
    = Int  {% Const.Int (valOf (toInt tokInt)) %}
    | Bool {% Const.Bool (valOf (toBool tokBool)) %}
    ;

# Patterns

piParam = Id typ=(':' nonArrowTyp {% nonArrowTyp %})? {% {var = valOf (toName tokId), typ} %};

pattern
    = pos apat typ=(':' typ {% typ %})? {% case typ
                                           of SOME typ => Term.AnnP (pos, {pat = apat, typ})
                                            | NONE => apat %}
    ;

paramPattern
    = pos apat typ=(':' nonArrowTyp {% nonArrowTyp %})? {% case typ
                                                           of SOME typ => Term.AnnP (pos, {pat = apat, typ})
                                                            | NONE => apat %}
    ;

apat
    = '(' pattern ')' {% pattern %}
    | pos Id          {% Term.Def (pos, valOf (toName tokId)) %}
    | pos const       {% Term.ConstP (pos, const) %}
    ;

