%name Broom;

%defs (
    structure Term = Cst.Term
    structure Type = Cst.Type
    datatype explicitness = datatype Cst.explicitness
    datatype effect = datatype Cst.effect

    datatype row
        = RecordFields of Term.recordFields
        | RowType of Type.typ

    fun block new pos stmts =
        case stmts
        of #[] => new (pos, #[], Term.Const (pos, Const.Unit))
         | _ => let val lastIndex = Vector.length stmts - 1
                in case Vector.sub (stmts, lastIndex)
                   of Term.Val _ =>
                       new (pos, stmts, Term.Const (pos, Const.Unit))
                    | Term.Expr body =>
                       let val stmts =
                               VectorSlice.vector (VectorSlice.slice (stmts, 0, SOME lastIndex))
                       in new (pos, stmts, body)
                       end
                end
);

%tokens
    : VAL ("val")
    | FUN ("fun")
    | TYPE ("type")
    | PI ("pi")
    | BEGIN ("begin")
    | DO ("do")
    | EXTENDS ("extends")
    | MODULE ("module")
    | INTERFACE ("interface")
    | FN ("fn")
    | MATCH ("match")
    | END ("end")
    | WITH ("with")
    | WHERE ("where")

    | DARROW ("=>")
    | EQ ("=")
    | ARROW ("->")
    | WARROW ("~>")
    | BAR ("|")
    | AMP ("&")
    | DDOT ("..")
    | DOT (".")
    | COMMA (",")
    | COLON (":")
    | SEMI (";")

    | LPAREN ("(")
    | RPAREN (")")
    | LBRACKET ("[")
    | RBRACKET ("]")
    | LBRACE ("{")
    | RBRACE ("}")

    | META of Name.t
    | ID of Name.t

    | INT of int
    | BOOL of bool
    ;

(* # Program *)

%start program;

program : stmts ;

(* # Statements *)

stmts : stmts=(firstStmt restStmts=restStmt* ";"?)? => (
        case stmts
        of SOME (stmt, stmts) => Vector.fromList (stmt :: stmts)
         | NONE => #[]
    );

firstStmt
    : def
    | expr => (Term.Expr expr)
    ;

restStmt
    : ";"? def
    | ";" expr => (Term.Expr expr)
    ;

def
    : "val" pattern "=" expr => (Term.Val (FULL_SPAN, pattern, expr))
    | "fun" ID pats=(apat => ((apat_SPAN, apat)))+ "=" expr => (
          let fun step ((pos, pattern), body) =
                  Term.Fn (pos, Explicit (), #[{pattern, body}])
          in Term.Val (FULL_SPAN, Term.Def (ID_SPAN, ID), List.foldr step expr pats)
          end
      )
    | "type" ID pats=(kpat => ((kpat_SPAN, kpat)))* "=" typ => (
          let fun step ((pos, {var = ID, typ}), body) =
                  Term.Fn ( pos, Explicit ()
                          , #[{pattern = Term.AnnP (pos, { pat = Term.Def (pos, ID), typ})
                                                         , body }])
          in Term.Val (FULL_SPAN, Term.Def (ID_SPAN, ID), List.foldr step (Term.Type (typ_SPAN, typ)) pats)
          end
      )
    ;

(* # Expressions *)

expr
    : ascription
    | "type" => (Term.Type (TYPE_SPAN, Type.TypeT TYPE_SPAN))
    ;

ascription : arrow typ=(":" typ)? => (
        case typ
        of SOME typ => Term.Ann (FULL_SPAN, arrow, typ)
         | NONE => arrow
    );

arrow
    : "pi" params=(piParam => ((piParam_SPAN, piParam)))+ arr body=arrow => (
        let fun step ((pos, param), body) = Type.Pi (pos, param, arr, body)
        in Term.Type (FULL_SPAN, List.foldr step (Type.Path body) params)
        end
      )
    | binapp codomain=(arr arrow)? => (
          case codomain
          of SOME (arr, cd) =>
              let val def = {var = Name.fresh (), typ = SOME (Type.Path binapp)}
              in Term.Type (FULL_SPAN, Type.Pi (FULL_SPAN, def, arr, Type.Path cd))
              end
           | NONE => binapp
      )
    ;

arr
    : "->" => (Explicit Pure)
    | "~>" => (Explicit Impure)
    | "=>" => (Implicit)
    ;

binapp : app ;

app : select selects=(select => (select_SPAN, select))* => (
        List.foldl (fn ((pos, arg), callee) => Term.App (pos, {callee, arg}))
                   select selects
    );

select : nestable fields=("." ID => ((ID_SPAN, ID)))* => (
        List.foldl (fn ((pos, field), r) => Term.Field (pos, r, field))
                   nestable fields
    );

nestable
    : "begin" stmts "end" => (block Term.Begin FULL_SPAN stmts)
    | "do" stmts "end" => (block Term.Do FULL_SPAN stmts)
    | "match" expr clauses=explicitClause+ "end" =>
          (Term.Match (FULL_SPAN, expr, Vector.fromList clauses))
    | "module" stmts "end" => (Term.Module (FULL_SPAN, stmts))
    | "interface" decl* "end" => (Term.Type (FULL_SPAN, Type.Interface (FULL_SPAN, Vector.fromList decl)))
    | "fn" fnClauses "end" => (
          let val (explicitness, clauses) = fnClauses
          in Term.Fn (FULL_SPAN, explicitness, clauses)
          end
      )
    | "{" row "}" => (
          case row
          of RecordFields fields => Term.Record (FULL_SPAN, fields)
           | RowType row => Term.Type (FULL_SPAN, Type.RecordT (FULL_SPAN, row))
      )
    | "(" "=" expr ")" => (Term.Type (FULL_SPAN, Type.Singleton (FULL_SPAN, expr)))
    | "(" expr ")"
    | atom
    ;

fnClauses : "|"? pattern=paramPattern clausesTail => (
        let val (explicitness, body, clauses) = clausesTail
        in (explicitness, Vector.fromList ({pattern, body} :: clauses))
        end
    );

clausesTail
    : "->" body=expr clauses=explicitClause* => ((Explicit (), body, clauses))
    | "=>" body=expr clauses=implicitClause* => ((Implicit, body, clauses))
    ;

explicitClause : "|" pattern=paramPattern "->" body=expr => ({pattern, body});
implicitClause : "|" pattern=paramPattern "=>" body=expr => ({pattern, body});

row
    : base=arrow row=( exprRowEdit* => (RecordFields {base = SOME base, edits = Vector.fromList exprRowEdit})
                     | typRowEdit => (RowType (Type.RowExt (FULL_SPAN, {base = Type.Path base, fields = typRowEdit}))) )
          => (row)
    | exprBaseFields exprRowEdit* => (
          RecordFields {base = NONE, edits = Vector.fromList (Term.With exprBaseFields :: exprRowEdit)}
      )
    | typRowFields => (RowType (Type.RowExt (FULL_SPAN, {base = Type.EmptyRow FULL_SPAN, fields = typRowFields})))
    | => (RecordFields {base = NONE, edits = #[]})
    | "&" typRowEdit => (RowType (Type.RowExt (FULL_SPAN, {base = Type.WildRow AMP_SPAN, fields = typRowEdit})))
    | "&" => (RowType (Type.WildRow FULL_SPAN))
    | ":" => (RowType (Type.EmptyRow FULL_SPAN))
    ;

exprRowEdit
    : "with" exprFields => (Term.With (Vector.fromList exprFields))
    | "where" exprFields => (Term.Where (Vector.fromList exprFields))
    ;

exprBaseFields : ID "=" expr tail=("," exprFields)? => (
        case tail
        of SOME tail => Vector.fromList ((ID, expr) :: tail)
         | NONE => #[(ID, expr)]
    );

exprFields : fields=(field=exprField fields=("," exprField)* => (field :: fields))? => (
        getOpt (fields, [])
    );

exprField : ID expr=("=" expr)? => (
        case expr
        of SOME expr => (ID, expr)
         | NONE => (ID, Term.Use (ID_SPAN, ID))
    );

typRowEdit : "with" typRowFields;

typRowFields : field=typRowField fields=("," typRowField)* => (Vector.fromList (field :: fields));

typRowField : ID ":" typ ;

atom
    : ID => (
          case Name.toString ID (* HACK *)
          of "int"  => Term.Type (ID_SPAN, Type.Prim (ID_SPAN, Type.Prim.I32))
           | "bool" => Term.Type (ID_SPAN, Type.Prim (ID_SPAN, Type.Prim.Bool))
           | "unit" => Term.Type (ID_SPAN, Type.Prim (ID_SPAN, Type.Prim.Unit))
           | _ => Term.Use (ID_SPAN, ID)
      )
    | const => (Term.Const (const_SPAN, const))
    ;

(* # Patterns *)

pattern : apat typ=(":" typ)? => (
        case typ
        of SOME typ => Term.AnnP (FULL_SPAN, {pat = apat, typ})
         | NONE => apat
    );

paramPattern : apat typ=(":" nonArrowTyp)? => (
        case typ
        of SOME typ => Term.AnnP (FULL_SPAN, {pat = apat, typ})
         | NONE => apat
    );

apat
    : "(" pattern ")"
    | ID => (Term.Def (ID_SPAN, ID))
    | const => (Term.ConstP (const_SPAN, const))
    ;

piParam
    : ID                 => ({var = ID, typ = NONE})
    | "(" ID ":" typ ")" => ({var = ID, typ = SOME typ})
    ;

kpat
    : ID                 => ({var = ID, typ = Type.TypeT FULL_SPAN})
    | "(" ID ":" typ ")" => ({var = ID, typ})
    ;

(* # Declarations *)

decl
    : "val" ID ":" typ => ((FULL_SPAN, ID, typ))
    | "type" ID pats=(kpat => ((kpat_SPAN, kpat)))* typ=("=" typ => ((typ_SPAN, typ)))? => (
          let fun step ((pos, {var, typ}), codomain) =
                  Type.Pi (pos, {var, typ = SOME typ}, Explicit Pure, codomain)
              val codomain =
                  case typ
                  of SOME (ptyp as (pos, typ)) => Type.Singleton (pos, Term.Type ptyp)
                   | NONE => Type.TypeT FULL_SPAN
          in (FULL_SPAN, ID, List.foldr step codomain pats)
          end
      )
    ;

(* # Types *)

typ : expr => (Type.Path expr);

nonArrowTyp
    : binapp => (Type.Path binapp)
    | "type" => (Type.TypeT TYPE_SPAN)
    ;

(* # Constants *)

const
    : INT  => (Const.Int INT)
    | BOOL => (Const.Bool BOOL)
    ;

