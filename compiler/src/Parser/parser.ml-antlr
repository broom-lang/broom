%name Broom;

%defs (
    structure Term = Cst.Term
    structure Type = Cst.Type
    datatype explicitness = datatype Cst.explicitness
);

%tokens
    : VAL ("val")
    | FUN ("fun")
    | TYPE ("type")
    | PI ("pi")
    | DO ("do")
    | MODULE ("module")
    | INTERFACE ("interface")
    | MATCH ("match")
    | END ("end")

    | DARROW ("=>")
    | EQ ("=")
    | ARROW ("->")
    | WARROW ("~>")
    | BAR ("|")
    | AMP ("&")
    | DDOT ("..")
    | DOT (".")
    | COMMA (",")
    | COLON (":")
    | SEMI (";")

    | LPAREN ("(")
    | RPAREN (")")
    | LBRACKET ("[")
    | RBRACKET ("]")
    | LBRACE ("{")
    | RBRACE ("}")

    | META of Name.t
    | ID of Name.t

    | INT of int
    | BOOL of bool
    ;

(* # Program *)

%start program;

program : stmts ;

(* # Statements *)

stmts : stmt* => (Vector.fromList stmt);

stmt
    : "val" pattern "=" expr => (Term.Val (FULL_SPAN, pattern, expr))
    | "fun" var pats=(apat => ((apat_SPAN, apat)))+ "=" expr => (
          let fun step ((pos, pattern), body) =
                  Term.Fn (pos, Explicit (), #[{pattern, body}])
          in Term.Val (FULL_SPAN, Term.Def (var_SPAN, var), List.foldr step expr pats)
          end
      )
    | "type" var pats=(kpat => ((kpat_SPAN, kpat)))* "=" typ => (
          let fun step ((pos, {var, typ}), body) =
                  Term.Fn ( pos, Explicit ()
                          , #[{pattern = Term.AnnP (pos, { pat = Term.Def (pos, var), typ})
                                                         , body }])
          in Term.Val (FULL_SPAN, Term.Def (var_SPAN, var), List.foldr step (Term.Type (typ_SPAN, typ)) pats)
          end
      )
    | ";" expr => (Term.Expr expr)
    ;

(* # Expressions *)

expr
    : atom
    ;

atom
    : var   => (Term.Use (var_SPAN, var))
    | const => (Term.Const (const_SPAN, const))
    ;

(* # Patterns *)

pattern
    : apat
    ;

apat
    : "(" pattern ")"
    | var => (Term.Def (var_SPAN, var))
    | const => (Term.ConstP (const_SPAN, const))
    ;

kpat
    : var                 => ({var, typ = Type.TypeT FULL_SPAN})
    | "(" var ":" typ ")" => ({var, typ})
    ;

(* # Types *)

typ : expr => (Type.Path expr);

(* # Atoms (for exprs and patterns) *)

var : ID => (ID);

const
    : INT  => (Const.Int INT)
    | BOOL => (Const.Bool BOOL)
    ;

