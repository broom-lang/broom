%name Broom;

%defs (
    structure Term = Cst.Term
    structure Type = Cst.Type
    datatype explicitness = datatype Cst.explicitness
    datatype effect = datatype Cst.effect
);

%tokens
    : VAL ("val")
    | FUN ("fun")
    | TYPE ("type")
    | PI ("pi")
    | DO ("do")
    | MODULE ("module")
    | INTERFACE ("interface")
    | MATCH ("match")
    | END ("end")

    | DARROW ("=>")
    | EQ ("=")
    | ARROW ("->")
    | WARROW ("~>")
    | BAR ("|")
    | AMP ("&")
    | DDOT ("..")
    | DOT (".")
    | COMMA (",")
    | COLON (":")
    | SEMI (";")

    | LPAREN ("(")
    | RPAREN (")")
    | LBRACKET ("[")
    | RBRACKET ("]")
    | LBRACE ("{")
    | RBRACE ("}")

    | META of Name.t
    | ID of Name.t

    | INT of int
    | BOOL of bool
    ;

(* # Program *)

%start program;

program : stmts ;

(* # Statements *)

stmts : stmt* => (Vector.fromList stmt);

stmt
    : "val" pattern "=" expr => (Term.Val (FULL_SPAN, pattern, expr))
    | "fun" ID pats=(apat => ((apat_SPAN, apat)))+ "=" expr => (
          let fun step ((pos, pattern), body) =
                  Term.Fn (pos, Explicit (), #[{pattern, body}])
          in Term.Val (FULL_SPAN, Term.Def (ID_SPAN, ID), List.foldr step expr pats)
          end
      )
    | "type" ID pats=(kpat => ((kpat_SPAN, kpat)))* "=" typ => (
          let fun step ((pos, {var = ID, typ}), body) =
                  Term.Fn ( pos, Explicit ()
                          , #[{pattern = Term.AnnP (pos, { pat = Term.Def (pos, ID), typ})
                                                         , body }])
          in Term.Val (FULL_SPAN, Term.Def (ID_SPAN, ID), List.foldr step (Term.Type (typ_SPAN, typ)) pats)
          end
      )
    | ";" expr => (Term.Expr expr)
    ;

(* # Expressions *)

expr
    : ascription
    | "type" => (Term.Type (TYPE_SPAN, Type.TypeT TYPE_SPAN))
    ;

ascription : arrow typ=(":" typ)? => (
        case typ
        of SOME typ => Term.Ann (FULL_SPAN, arrow, typ)
         | NONE => arrow
    );

arrow
    : "pi" piParam arr body=arrow => (Term.Type (FULL_SPAN, Type.Pi (FULL_SPAN, piParam, arr, Type.Path body)))
    | binapp codomain=(arr arrow)? => (
          case codomain
          of SOME (arr, cd) =>
              let val def = {var = Name.fresh (), typ = SOME (Type.Path binapp)}
              in Term.Type (FULL_SPAN, Type.Pi (FULL_SPAN, def, arr, Type.Path cd))
              end
           | NONE => binapp
      )
    ;

arr
    : "->" => (Explicit Pure)
    | "~>" => (Explicit Impure)
    | "=>" => (Implicit)
    ;

binapp : app ;

app : select selects=(select => (select_SPAN, select))* => (
        List.foldl (fn ((pos, arg), callee) => Term.App (pos, {callee, arg}))
                   select selects
    );

select : nestable fields=("." ID => ((ID_SPAN, ID)))* => (
        List.foldl (fn ((pos, field), r) => Term.Field (pos, r, field))
                   nestable fields
    );

nestable
    : "{" clauses "}" => (
          let val (explicitness, clauses) = clauses
          in Term.Fn (FULL_SPAN, explicitness, clauses)
          end
      )
    | "{" exprRow "}" => (Term.Record (FULL_SPAN, exprRow))
    | atom
    ;

clauses : "|" pattern=paramPattern clausesTail => (
        let val (explicitness, body, clauses) = clausesTail
        in (explicitness, Vector.fromList ({pattern, body} :: clauses))
        end
    );

clausesTail
    : "->" body=expr clauses=explicitClause* => ((Explicit (), body, clauses))
    | "=>" body=expr clauses=implicitClause* => ((Implicit, body, clauses))
    ;

explicitClause : "|" pattern=paramPattern "->" body=expr => ({pattern, body});
implicitClause : "|" pattern=paramPattern "=>" body=expr => ({pattern, body});

exprRow : fields=(exprRowField ("," exprRowField)*)? ext=exprRowExt? => (
        { fields = case fields
                   of SOME (field, fields) => Vector.fromList (field :: fields)
                    | NONE => #[]
        , ext }
    );

exprRowField : ID expr=("=" expr)? => (
        case expr
        of SOME expr => (ID, expr)
         | NONE => (ID, Term.Use (ID_SPAN, ID))
    );

exprRowExt : ".." expr ;

atom
    : ID   => (Term.Use (ID_SPAN, ID))
    | const => (Term.Const (const_SPAN, const))
    ;

(* # Patterns *)

pattern
    : apat
    ;

paramPattern : apat typ=(":" nonArrowTyp)? => (
        case typ
        of SOME typ => Term.AnnP (FULL_SPAN, {pat = apat, typ})
         | NONE => apat
    );

apat
    : "(" pattern ")"
    | ID => (Term.Def (ID_SPAN, ID))
    | const => (Term.ConstP (const_SPAN, const))
    ;

piParam : ID typ=(":" nonArrowTyp)? => ({var = ID, typ});

kpat
    : ID                 => ({var = ID, typ = Type.TypeT FULL_SPAN})
    | "(" ID ":" typ ")" => ({var = ID, typ})
    ;

(* # Types *)

typ : expr => (Type.Path expr);

nonArrowTyp
    : binapp => (Type.Path binapp)
    | "type" => (Type.TypeT TYPE_SPAN)
    ;

(* # Constants *)

const
    : INT  => (Const.Int INT)
    | BOOL => (Const.Bool BOOL)
    ;

