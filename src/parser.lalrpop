grammar<'input>;

use crate::pos::{Pos, Positioned};
use crate::lexer::{self, Tok};
use crate::cst::{Expr, SpanningExpr, Stmt, SpanningStmt};

extern {
    type Location = Pos;
    type Error = Positioned<lexer::Error>;

    enum Tok<'input> {
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,

        "=" => Tok::Eq,
        ";" => Tok::Semi,

        Id => Tok::Id(<&'input str>),

        Int => Tok::Int(<isize>)
    }
}

pub Expr = App;

App : SpanningExpr = {
    <start:@L> <callee:App> <arg:Nestable> <end:@R> => Expr::App(Box::new(callee), Box::new(arg)).spanning(start, end),

    Nestable
}

Nestable: SpanningExpr = {
    <start:@L> "{" <stmts:Stmts> "}" <end:@R> => Expr::Record(stmts).spanning(start, end),
    
    "(" <Expr> ")",

    <start:@L> <id:Id> <end:@R> => Expr::Id(String::from(id)).spanning(start, end),

    <start:@L> <n:Int> <end:@R> => Expr::Int(n).spanning(start, end),
}

Stmt: SpanningStmt = {
    <start:@L> <pat:Expr> "=" <expr:Expr> <end:@R> => Stmt::Def(pat, expr).spanning(start, end),
    <start:@L> <expr:Expr> <end:@R> => Stmt::Expr(expr).spanning(start, end)
}

Stmts: Vec<SpanningStmt> = {
    <stmts:(<Stmt> <(";" <Stmt>)*>)?> ";"? => match stmts {
        Some((stmt, mut stmts)) => {
            stmts.insert(0, stmt);
            stmts
        },
        None => Vec::new()
    }
}
