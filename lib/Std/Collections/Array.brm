type ARRAY = interface
    type t elem
    type size = uint
    type key = uint

    val count : forall elem => t elem -> size
    val get : forall elem => t elem -> key -> elem
    val set : forall elem => t elem -> key -> elem -> t elem
    val update : forall elem => t elem -> key -> (elem -> elem) -> t elem

    val unfoldl : forall elem elem => size -> (state -> elem * state) -> state -> t elem * state
    val unfoldr : forall elem state => size -> (state -> elem * state) -> state -> t elem * state

    val foldl : forall elem state => (state -> elem -> state) -> state -> t elem -> state
    val foldr : forall elem state => (elem -> state -> state) -> state -> t elem -> state
end

val Array : ARRAY = module
    type t elem = __array elem
    type size = uint
    type key = uint

    fun count arr = __arrayCount arr

    fun get arr i = __arrayGet arr i

    fun set arr i v =
        unfoldl (count arr) {
            | i' when i' == i -> (v, i' - 1)
            | i' -> (get arr i', i' - 1)
        }

    fun update arr = set arr i (f (get arr i))

    # TODO: Add 'unsafe' effect to `set` and `build` when effect system appears:
    val Builder : interface
        type t elem

        val new : forall elem => size -> t elem
        val set : forall elem => t elem -> key -> elem -> unit
        val build : forall elem => t elem -> Array.t elem
    end = module
        type t elem = __array elem

        fun new len = __arrayNew len
        fun set builder i v = __arrayUnsafeSet builder i v
        val build = Fn.id
    end

    fun unfoldl len f state = begin
        val builder = Builder.new len
        fun loop state = {
            | i when i > 0 -> begin
                val i' = i - 1
                val (v, state') = f state
                do Builder.set builder i' v
                return loop state' i'
            end
            |Â _ -> Builder.build builder
        }
        return loop state len
    end

    fun unfoldr len f state = begin
        val builder = Builder.new len
        fun loop state = {
            | i when i < len -> begin
                val (v, state') = f state
                do Builder.set builder i v
                return loop state' (i + 1)
            end
            | _ -> Builder.build builder
        }
        return loop state 0
    end

    fun foldl f state arr = begin
        val len = count arr
        fun loop state = {
            | i when i < len -> loop (f state (get arr i)) (i + 1)
            | _ -> state
        }
        return loop state 0
    end

    fun foldr f state arr = begin
        fun loop state = {
            | i when i > 0 ->
                i' = i - 1
                loop (f (get arr i') state) i'
            | _ -> state
        }
        return loop state (count arr)
    end
end

