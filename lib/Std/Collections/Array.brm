ARRAY = {|
    type t a;
    size = __uint; -- TODO: Get this from its module
    key = __uint;

    count : a => t a -> size;
    get : a => (t a, key) -> a;
    set : a => (t a, key, a) -> t a;
    update : (a, e) => (t a, key, (a ~> e ! a)) ~> e ! t a;

    unfoldl : (a, s, e) => (size, (s ~> e ! {a : a; s : s}), s)
        ~> e ! {array : t a; s : s};
    unfoldr : (a, s, e) => (size, (s ~> e ! {a : a; s : s}), s)
        ~> e ! {array : t a; s : s};

    foldl : (a, s, e) => (((s, a) ~> e ! s), s, t a) ~> e ! s;
    foldr : (a, s, e) => (((a, s) ~> e ! s), s, t a) ~> e ! s;
};

Array : ARRAY = {
    type t a = __array a;
    size = __uint;
    key = __uint;

    fun count arr = __arrayCount arr;

    fun get arr i = __arrayGet arr i;

    fun set arr i v =
        unfoldl (count arr) [| i' -> match (i' == i) [
                | True -> {elem = v; state = i' - 1}
                | False -> {elem = get arr i'; state = i' - 1}
            ]
        ]
        (count arr - 1)

    fun update arr = set arr i (f (get arr i));

    -- TODO: Add 'unsafe' effect to `set` and `build` when )effect system appears:
    Builder : {|
        type t a;

        new : a => size -> t a;
        set : a => (t a, key, a) -> ();
        build : a => t a -> Array.t a;
    } = {|
        type t a = __array a;

        fun new len = __arrayNew len;
        fun set builder i v = __arrayUnsafeSet builder i v;
        build = Fn.id;
    };

    fun unfoldl len f state = let {
        builder = Builder.new len;
        fun loop state i = match (i > 0) [
            | True -> begin {
                i = i - 1;
                es = f state;
                Builder.set builder i es.elem;
                loop es.state i
            }
            | False -> Builder.build builder
        ];
        loop state len
    };

    fun unfoldr len f state = let {
        builder = Builder.new len;
        fun loop state i = match (i < len) [
            | True -> begin {
                es = f state;
                Builder.set builder i es.elem;
                loop es.state (i + 1)
            }
            | False -> Builder.build builder
        ];
        loop state 0
    };

    fun foldl f state arr = let {
        len = count arr;
        fun loop state i = match (i < len) [
            | True -> loop (f state (get arr i)) (i + 1)
            | False -> state
        ];
        loop state 0
    };

    fun foldr f state arr = let {
        fun loop state i = match (i > 0) [
            | True -> begin {
                i = i - 1;
                loop (f (get arr i) state) i
            }
            | False -> state
        ];
        loop state (count arr)
    };
};

