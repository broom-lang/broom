type ARRAY = interface
    type t elem
    type size = uint
    type key = uint

    val count : pi elem => t elem -> size
    val get : pi elem => t elem -> key -> elem
    val set : pi elem => t elem -> key -> elem -> t elem
    val update : pi elem => t elem -> key -> (elem -> elem) -> t elem

    val unfoldl : pi elem state => size -> (state -> {elem : elem, state : state}) -> state
        -> {array : t elem, state : state}
    val unfoldr : pi elem state => size -> (state -> {elem : elem, state : state}) -> state
        -> {array : t elem, state : state}

    val foldl : pi elem state => (state -> elem -> state) -> state -> t elem -> state
    val foldr : pi elem state => (elem -> state -> state) -> state -> t elem -> state
end

val Array : ARRAY = module
    type t elem = __array elem
    type size = uint
    type key = uint

    fun count arr = __arrayCount arr

    fun get arr i = __arrayGet arr i

    fun set arr i v =
        unfoldl (count arr) fn
            | i' when i' == i -> (v, i' - 1)
            | i' -> (get arr i', i' - 1)
        end

    fun update arr = set arr i (f (get arr i))

    # TODO: Add 'unsafe' effect to `set` and `build` when effect system appears:
    val Builder : interface
        type t elem

        val new : pi elem => size -> t elem
        val set : pi elem => t elem -> key -> elem -> unit
        val build : pi elem => t elem -> Array.t elem
    end = module
        type t elem = __array elem

        fun new len = __arrayNew len
        fun set builder i v = __arrayUnsafeSet builder i v
        val build = Fn.id
    end

    fun unfoldl len f state = begin
        val builder = Builder.new len
        fun loop state = fn
            | i when i > 0 -> begin
                val i' = i - 1
                val {elem, state = state'} = f state
                ; Builder.set builder i' elem;
                ; loop state' i'
            end
            |Â _ -> Builder.build builder
        end
        ; loop state len
    end

    fun unfoldr len f state = begin
        val builder = Builder.new len
        fun loop state = fn
            | i when i < len -> begin
                val {elem, state = state'} = f state
                ; Builder.set builder i elem 
                ; loop state' (i + 1)
            end
            | _ -> Builder.build builder
        end
        ; loop state 0
    end

    fun foldl f state arr = begin
        val len = count arr
        fun loop state = fn
            | i when i < len -> loop (f state (get arr i)) (i + 1)
            | _ -> state
        end
        ; loop state 0
    end

    fun foldr f state arr = begin
        fun loop state = fn
            | i when i > 0 ->
                i' = i - 1
                loop (f (get arr i') state) i'
            | _ -> state
        end
        ; loop state (count arr)
    end
end

