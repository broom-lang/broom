Parsers : {|
} = {
    Char = require Std.Char;
    String = require Std.String;
    State = require Std.Eff.State;

    Error = enum {
        type t;

        EndOfInput : t;
        Expected : {|expected : Char.t; actual : Char.t} => t;
    };

    error = Error.t;

    type t a = () ~> (|State : State.t String.Slice.t; Error : error) ! a;

    anyChar : t Char.t = [
        match (String.Slice.uncons (! ('State (State.Get {})))) [
        | Some {first; rest} -> begin {
            ! ('State (State.Set rest));
            first
        }
        | None {} -> ! (`Error 'Error.EndOfInput)
        ]
    ];

    char : Char.t -> t Char.t = [| expected -> [
        match (anyChar @) [
        | actual when actual == expected -> actual
        | actual -> ! ('Error ('Error.Expected {expected; actual}))
        ]
    ]];

    (<|>) : a => (t a, t a) -> t a = [| a @ parser parser' -> [
        match (parser @) [
        | v -> v
        | effect (`Error _) _ -> parser' {}
        ]
    ]];

    build : a => (t a, String.t) ~> (|Error : error) ! a = [| a @ parser cs ->
        State.eval parser (String.Slice.from cs)
    ];
};

